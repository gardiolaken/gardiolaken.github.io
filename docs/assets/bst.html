<html>
  <head>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.14.7/dist/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.3.1/dist/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>
  </head>
  <style>
    html{
    width:100%;
    height:100%;
}
.intro {
    height: 100vh;
    width: 100%;
    background-image: url(Images/ottawa.png);
    background-position: center;
    background-repeat: no-repeat;
    background-size: cover;
}

.centered_home {
    font-family: Arial,Helvetica,sans-serif;
    font-size: 150%;
    color: #fff;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%,-50%);
}

.container img {
    padding: 5%;
}

.node_logo {
    width: 150px;
    height: 100px;
    display: block;
    margin-left: auto;
    margin-right: auto;
    margin-top: 5%;
}

.logos {
    width: 100px;
    height: 100px;
    display: block;
    margin-left: auto;
    margin-right: auto;
    margin-top: 5%;
}


.row_home {
    width: 80%;
    margin: auto;
    margin-top: 1%;
    margin-bottom: 1%;
}

.exp_body {
    height: 100%;
}


/* Container holding the image and the text */

/* Centered text */

.card-title {
    font-size: 175%;
    font-family: Arial, Helvetica, sans-serif;
}

li.borderless {
    border-top: 0 none;
}

.centered {
    display: flex;
    align-items: center;
    justify-content: center;
}

.bst_alert {
    transform: scale(0.8, 0.8);
}

.div_bst_alert{
    position:relative;
    width:26%;
    left:37%;
    margin-top:1%;
}

.div_view_project{
    padding-right:3%;
}

.alert{
    margin-bottom: 0rem;
}

pre code {
    background-color: #eee;
    border: 1px solid #999;
    display: block;
    padding: 20px;
}

.question{
    height:70vh;

}

.homework{
    margin-top:3%;
}

.navhome{
    height:5%;
}

.bod{
    height:95%;
    margin-top:5%;
}
  </style>
  <script src="https://code.jquery.com/jquery-3.5.1.slim.min.js" integrity="sha384-DfXdz2htPH0lsSSs5nCTpuj/zy4C+OGpamoFVy38MVBnE+IbbVYUew+OrCXaRkfj" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-ho+j7jyWK8fNQe+A12Hb8AhRq26LrZ/JpcUGGOn+Y7RsweNrtN/tE3MoK7ZeZDyx" crossorigin="anonymous"></script>
    <div class="play">
        <div class="card text-center">
            <div class="card-header">
                Project Dec 2021
            </div>
            <div class="card-body">
                <h5 class="card-title">
                    Visualizing the Binary Search Tree Data Structure Algorithm using
                    Html,CSS,JavaScript
                </h5>

                <div class="col-md-12">
                    <div class="input-group input-group-sm w-25 mx-auto">
                        <input type="text" class="form-control" id="node" name="node" placeholder="enter number to add in bst">
                        <div class="input-group-prepend">
                            <button class="btn btn-outline-secondary" type="button" id="addNodeButton" onclick="addNode()">Add</button>
                        </div>
                    </div>
                </div>


                @*ALERTS*@

                <div class="div_bst_alert">
                    <div id="bst_logs" class="alert bst_alert fade show" role="alert" data-dismiss="alert">
                        &nbsp
                    </div>
                </div>


                <div>
                    <canvas id="myCanvas"></canvas>
                </div>



            </div>

        </div>
        <div class="container">
            <div class="card">
                <h5 class="card-header">Documentation</h5>
                <div class="card-body">
                    <h5 class="card-title">Design</h5>
                    <p class="card-text">
                        I had many iterations for this project as I did not really know how to use canvas and thus was not able to design prior to creating the project.
                        The design I ended up with is animate while in the bst algorithm code which isn‚Äôt the best but I had to rewrite a lot of my code so üòê.
                        Basically my code works like this -- with the recursion of the bst algorithm I call the animate functions. The code below is for going left
                        in the algorithm where the current node data is greater than what is being added.
                    </p>


                    <pre>
                    <code>
                                    else if (node.data > newNode.data) { // go left ---------------
                                    log(0, node.data + " is GREATER than " + newNode.data + ". Go Left")
                                        if (node.left === null) {

                                        newNode.parent = node;           //assigning object attributes
                                        newNode.position = 0;
                                        newNode.y = node.y + 100;
                                        newNode.level = node.level + 1;

                                        if (newNode.level > 3) {        //limit bst level to 3
                                            log(1, "Constraint: BST max level is set to 3")
                                            document.getElementById("addNodeButton").disabled = false;
                                        }
                                        else {
                                            if (newNode.level > this.bst_level) {    //remap BST coordinates in canvas
                                                this.bst_level = newNode.level;
                                                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                                                this.mapBST(this.root);

                                                //draw parent connect
                                                this.connectToRoot(node);
                                            }

                                        node.left = newNode;
                                        document.getElementById("addNodeButton").disabled = false;

                                         //equation to calculate dynamic x coordinates of nodes
                                        let temp = (Math.pow(2, (this.bst_level - node.level - 1)) * 80);
                                        let baseX, baseY, toX, toY = null;
                                        newNode.x = node.x - temp;

                                        //animate

                                        await animateExpand(node.x, node.y);
                                        await animateClose(node.x, node.y);
                                        await animateline(node.x, node.y, newNode.x, newNode.y);
                            </code>
                        </pre>


                    <p>
                        As you can see in this design, the animation part of the application is done together with the bst algorithm. This includes calculating the coordinates of the nodes
                        to be drawn in the canvas, animation effects, drawing connecting lines etc.. The better design that I had in mind was to isolate the animation and bst algorithm. Which
                        would make the code cleaner and have would have made the redesigning and debugging better.
                    </p>


                    <h5 class="card-title display-4">How It Works</h5>
                    <h6 class="card-subtitle">Asynchronous Code</h6>

                    <p>
                        To implement my design, I had to use async await to allow the animation to be executed in between instances of the recursion. The code below shows the animation functions to
                        return promises.
                    </p>

                    <pre>
                    <code>
                            async function animateExpand(x, y) {
                                return new Promise(async (resolve, reject) => {
                                    var pos = 0;
                                    var id = setInterval(frame, 10)

                                    async function frame() {
                                        if (pos >= 9) {
                                            clearInterval(id);
                                            resolve("expand done")
                                        }
                                        else {
                                            pos = pos + 0.1;
                                            ctx.beginPath();
                                            ctx.strokeStyle = 'Aquamarine';
                                            ctx.arc(x, y, 16 + pos, 0 * Math.PI, 2 * Math.PI);
                                            ctx.stroke();
                                            ctx.closePath();
                                        }
                                    }
                                })
                            }

                            async function animateClose(x, y) {
                                return new Promise(async (resolve, reject) => {
                                    var pos = 10;
                                    var id = setInterval(frame, 10)

                                    async function frame() {
                                        if (pos <= 0) {
                                            clearInterval(id);
                                            resolve("closeAnimate done");

                                        }
                                        else {
                                            pos = pos - 0.1;
                                            ctx.beginPath();
                                            ctx.strokeStyle = 'white';
                                            ctx.arc(x, y, 16 + pos, 0 * Math.PI, 2 * Math.PI);
                                            ctx.stroke();
                                            ctx.closePath();
                                        }
                                    }
                                })
                            }

                            async function animateline(baseX, baseY, toX, toY) {
                                return new Promise(async (resolve, reject) => {
                                    var direction = null;
                                    if (toX < baseX) {
                                        //go left
                                        direction = -1;
                                        baseX = baseX - 15;
                                        baseY = baseY + 15;
                                        toX = toX + 15;
                                        toY = toY - 15;
                                    }
                                    else {
                                        direction = 1;
                                        baseX = baseX + 15;
                                        baseY = baseY + 15;
                                        toX = toX - 15;
                                        toY = toY - 15;
                                    }
                                    var timer = 0;
                                    var id = setInterval(frame, 10);
                                    var adjustedX = toX - baseX;
                                    var adjustedY = toY - baseY;
                                    adjustedY = Math.abs(adjustedY / 100);
                                    adjustedX = Math.abs(adjustedX / 100);

                                    async function frame() {
                                        if (timer == 100) {
                                            clearInterval(id);
                                            resolve("animateline done");
                                        }
                                        else {

                                            timer++;
                                            console.log(baseX, baseY, toX, toY)
                                            baseX = baseX + (direction * adjustedX);;
                                            baseY = baseY + adjustedY;
                                            ctx.strokeStyle = 'Aquamarine';
                                            ctx.beginPath();
                                            ctx.moveTo(baseX + (2 * direction), baseY - 2);
                                            ctx.lineTo(baseX + (2 * direction * -1), baseY + 2);
                                            ctx.stroke();
                                            ctx.closePath();
                                        }
                                    }
                                })
                            }
                        </code>
                        </pre>

                    <br />

                    <h5 class="card-subtitle"> Maths </h5>
                    <br />
                    <h6 class="card-subtitle"> X Coordinates </h6>

                    <p>
                        As you add a level on the bst, you can see the tree being remapped to fit the next level of nodes. This is probably where I had the longest time to debunk. I found out that
                        the distance between the node coordinates is calculated by the difference of BST level and the current node level. Since this is a binary tree, the next level below means you need to make space
                        for 2 times the amount of what the current level has. To explain this better see my paints skills below.
                    </p>

                    <img src="../assets/Images/bst_x_calc.png" class="img-fluid" />

                    <p>
                        Basically, calculate the space needed for everything under you(the current node) Hence the (this.bst_level - node.level - 1). And that should give you the distance to your parent node.
                        newNode.x = node.x - temp;
                    </p>
                    <p>
                        <b>this.bst level</b> is the level of the binary search tree <br />
                        <b>node.level</b> is the level of the node being placed in the canvas <br />
                        <b>80</b> is the x distance between xs  <br />
                        <b>newNode.x</b> new node to be added x attribute <br />



                        <pre>
                        <code>
                            let temp = (Math.pow(2, (this.bst_level - node.level - 1)) * 80);
                            newNode.x = node.x - temp;
                        </code>
                    </pre>

                        <h6 class="card-subtitle"> Connect Line Animation </h6>
                    <p>
                        Animation is possible with the <b>setInterval(frame, 10)</b> function. Basically it runs frame function every 10 milliseconds <br />
                        For the animation to work, I needed to calculate the x,y points of the line connecting the nodes. I decided to go with 100 instances for the animation.
                        This number is the speed on which the animation would work -- higher = slower. Dividing this number by the length of the x and y would give me where to draw
                        the next point every instance of the setInterval function with even steps of both x and y. Direction - is needed since this function is used both nodes going left or right.
                    </p>
                    <div class="col-md-12">
                        <div class="input-group input-group-sm w-25 mx-auto">
                            <input type="text" class="form-control" id="example_line" name="node" placeholder="enter speed">
                            <div class="input-group-prepend">
                                <button class="btn btn-outline-secondary" type="button" id="example_line_button" onclick="changespeed()">Start</button>
                            </div>
                        </div>
                    </div>
                    <canvas id="animate_line_example"></canvas>
                    <pre>
                    <code>
                                async function animateline(baseX, baseY, toX, toY) {
                                return new Promise(async (resolve, reject) => {
                                    var direction = null;
                                    if (toX < baseX) {
                                        //go left
                                        direction = -1;
                                        baseX = baseX - 15;
                                        baseY = baseY + 15;
                                        toX = toX + 15;
                                        toY = toY - 15;
                                    }
                                    else {
                                        direction = 1;
                                        baseX = baseX + 15;
                                        baseY = baseY + 15;
                                        toX = toX - 15;
                                        toY = toY - 15;
                                    }
                                    var timer = 0;
                                    var id = setInterval(frame, 10);
                                    var adjustedX = toX - baseX;
                                    var adjustedY = toY - baseY;
                                    adjustedY = Math.abs(adjustedY / 100);
                                    adjustedX = Math.abs(adjustedX / 100);

                                    async function frame() {
                                        if (timer == 100) {
                                            clearInterval(id);
                                            resolve("animateline done");
                                        }
                                        else {

                                            timer++;
                                            console.log(baseX, baseY, toX, toY)
                                            baseX = baseX + (direction * adjustedX);;
                                            baseY = baseY + adjustedY;
                                            ctx.strokeStyle = 'Aquamarine';
                                            ctx.beginPath();
                                            ctx.moveTo(baseX + (2 * direction), baseY - 2);
                                            ctx.lineTo(baseX + (2 * direction * -1), baseY + 2);
                                            ctx.stroke();
                                            ctx.closePath();
                                        }
                                    }
                                })
                            }
                            </code>
                        </pre>

                    <h6 class="card-subtitle">Whole JavaScript Code</h6>


                    <pre>
                    <code>

                        //Author : Kenneth Gardiola
                        //Date   : 2021

                        var startY = 30;
                        var x = 0;
                        var y = 0;
                        var canvas = document.getElementById('myCanvas');
                        var ctx = canvas.getContext('2d');

                        ctx.canvas.width = window.innerWidth;
                        ctx.canvas.height = window.innerHeight * 0.50;

                        ctx.fillStyle = 'black';
                        ctx.strokeStyle = 'black';
                        ctx.font = "20px Arial";


                        class Node {
                            constructor(data) {
                                this.data = data;
                                this.x = null;
                                this.y = null;
                                this.left = null;
                                this.right = null;
                                this.position = null; // left(0) or right(1) - needed to dynamically adjust position of leaf node. x-axis changes. adding new level require x-axis adjustment to fit and not overlap nodes
                                this.parent = null;
                                this.level = null;
                            }
                        }

                        class BinarySearchTree {
                            constructor() {
                                this.root = null;
                                this.bst_level = null;
                            }


                            async insert(data) {
                                //clear canvas
                                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                                //disable button until animation finish
                                document.getElementById("addNodeButton").disabled = true;
                                this.mapBST(this.root);
                                var newNode = new Node(data);

                                if (this.root === null) {
                                    this.root = newNode;
                                    this.bst_level = 0;
                                    newNode.level = 0;
                                    newNode.x = ctx.canvas.width / 2 - 30;
                                    newNode.y = startY;
                                    createCircle(newNode.x, newNode.y, newNode.data);
                                    document.getElementById("addNodeButton").disabled = false;
                                    await animateExpand(newNode.x, newNode.y);

                                    log(0, "Root Node Created");

                                }
                                else {
                                    this.insertNode(this.root, newNode);
                                }
                            }


                            async insertNode(node, newNode) {

                                //if data = data
                                if (node.data == newNode.data) {
                                    //TODO
                                    log(0, "Values equals each other")
                                    document.getElementById("addNodeButton").disabled = false;
                                }
                                else if (node.data > newNode.data) { // go left ---------------
                                    log(0, node.data + " is GREATER than " + newNode.data + ". Go Left")
                                    if (node.left === null) {

                                        newNode.parent = node;
                                        newNode.position = 0;
                                        newNode.y = node.y + 100;
                                        newNode.level = node.level + 1;

                                        if (newNode.level > 3) {  //limit bst level to 3
                                            log(1, "Constraint: BST max level is set to 3")
                                            document.getElementById("addNodeButton").disabled = false;
                                        }
                                        else {
                                            if (newNode.level > this.bst_level) { //remap BST coordinates
                                                this.bst_level = newNode.level;
                                                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                                                this.mapBST(this.root);
                                                //draw connect to parent until root
                                                this.connectToRoot(node);
                                            }

                                            node.left = newNode;
                                            document.getElementById("addNodeButton").disabled = false;
                                            //new
                                            let temp = (Math.pow(2, (this.bst_level - node.level - 1)) * 80);
                                            let baseX, baseY, toX, toY = null;
                                            newNode.x = node.x - temp;

                                            //animate

                                            await animateExpand(node.x, node.y);
                                            await animateClose(node.x, node.y);
                                            await animateline(node.x, node.y, newNode.x, newNode.y);


                                            log(0, "Node " + newNode.data + " added.")



                                            connectCircle(baseX, baseY, toX, toY);
                                            createCircle(newNode.x, newNode.y, newNode.data);
                                            await animateExpand(newNode.x, newNode.y);
                                            createCircle(newNode.x, newNode.y, newNode.data);
                                        }


                                    }
                                    else {
                                        await animateExpand(node.x, node.y);
                                        await animateClose(node.x, node.y);
                                        await animateline(node.x, node.y, node.left.x, node.left.y)
                                        this.insertNode(node.left, newNode);
                                    }
                                }

                                else {                                                      // go right --------------
                                    log(0, node.data + " is LESS than " + newNode.data + ". Go Right")
                                    if (node.right === null) {

                                        newNode.parent = node;
                                        newNode.position = 1;
                                        newNode.y = node.y + 100;
                                        newNode.level = node.level + 1;
                                        if (newNode.level > 3) {  //limit bst level to 3
                                            log(1, "Constraint: BST max level is set to 3")
                                            document.getElementById("addNodeButton").disabled = false;
                                        }
                                        else {
                                            if (newNode.level > this.bst_level) {
                                                this.bst_level = newNode.level;
                                                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                                                this.mapBST(this.root);
                                                this.connectToRoot(node);
                                            }

                                            node.right = newNode;
                                            document.getElementById("addNodeButton").disabled = false;


                                            let temp = (Math.pow(2, (this.bst_level - node.level - 1)) * 80);
                                            let baseX, baseY, toX, toY = null;
                                            newNode.x = node.x + temp;

                                            //animation
                                            await animateExpand(node.x, node.y);
                                            await animateClose(node.x, node.y);
                                            await animateline(node.x, node.y, newNode.x, newNode.y);

                                            log(0, "Node " + newNode.data + " added.")

                                            connectCircle(baseX, baseY, toX, toY);
                                            createCircle(newNode.x, newNode.y, newNode.data);
                                            await animateExpand(newNode.x, newNode.y);
                                            createCircle(newNode.x, newNode.y, newNode.data);
                                        }

                                    }
                                    else {
                                        await animateExpand(node.x, node.y);
                                        await animateClose(node.x, node.y);
                                        await animateline(node.x, node.y, node.right.x, node.right.y);
                                        this.insertNode(node.right, newNode);
                                    }
                                }

                            }


                            mapBST(node) {
                                if (node !== null) {

                                    if (this.root !== node) {
                                        let temp = (Math.pow(2, (this.bst_level - node.parent.level - 1)) * 80);
                                        if (node.position == 0) {
                                            node.x = node.parent.x - temp;
                                        }
                                        else {
                                            node.x = node.parent.x + temp;
                                        }
                                        createCircle(node.x, node.y, node.data);
                                        connectCircle(node.parent.x,node.parent.y,node.x, node.y);

                                    }
                                    else {
                                        //draw root node
                                        createCircle(node.x, node.y, node.data);
                                    }
                                    this.mapBST(node.left);
                                    this.mapBST(node.right);
                                }

                            }

                            connectToRoot(node) {

                                if (this.root !== node) {

                                    let baseX, baseY, toX, toY = null;
                                    if (node.position == 0) {
                                        baseX = node.parent.x - 15;
                                        baseY = node.parent.y + 15;
                                        toX = node.x + 15;
                                        toY = node.y - 15;
                                    }
                                    else {
                                        baseX = node.parent.x + 15;
                                        baseY = node.parent.y + 15;
                                        toX = node.x - 15;
                                        toY = node.y - 15;
                                    }
                                    ctx.beginPath();
                                    ctx.strokeStyle = 'Aquamarine';
                                    ctx.moveTo(baseX, baseY);
                                    ctx.lineTo(toX, toY);
                                    ctx.lineWidth = 5;
                                    ctx.stroke();
                                    ctx.closePath();
                                    ctx.lineWidth = 1;
                                    connectCircle(node.parent.x, node.parent.y, node.x, node.y);
                                    this.connectToRoot(node.parent);
                                }
                                else {
                                    console.log("reached root");
                                }

                            }

                        }

                        function addNode() {
                            let nodeName = parseInt(document.getElementById("node").value);
                            console.log("inserting" + nodeName);
                            BST.insert(nodeName);
                        }

                        function createCircle(x, y, number) {
                            ctx.beginPath();
                            ctx.fillStyle = 'black';
                            ctx.strokeStyle = 'black';
                            ctx.fillText(number, x - 10, y + 8)


                            ctx.arc(x, y, 15, 0 * Math.PI, 2 * Math.PI);
                            ctx.stroke();
                            ctx.closePath();
                        }

                        function connectCircle(baseX, baseY, toX, toY) {
                            if (toX < baseX) {
                                //go left
                                baseX = baseX - 15;
                                baseY = baseY + 15;
                                toX = toX + 15;
                                toY = toY - 15;
                            }
                            else {
                                baseX = baseX + 15;
                                baseY = baseY + 15;
                                toX = toX - 15;
                                toY = toY - 15;
                            }

                            ctx.beginPath();
                            ctx.strokeStyle = 'black';
                            ctx.moveTo(baseX, baseY);
                            ctx.lineTo(toX, toY);
                            ctx.stroke();
                            ctx.closePath();
                        }

                        //animation

                        async function animateExpand(x, y) {
                            return new Promise(async (resolve, reject) => {
                                var pos = 0;
                                var id = setInterval(frame, 10)

                                async function frame() {
                                    if (pos >= 9) {
                                        clearInterval(id);
                                        resolve("expand done")
                                    }
                                    else {
                                        pos = pos + 0.1;
                                        ctx.beginPath();
                                        ctx.strokeStyle = 'Aquamarine';
                                        ctx.arc(x, y, 16 + pos, 0 * Math.PI, 2 * Math.PI);
                                        ctx.stroke();
                                        ctx.closePath();
                                    }
                                }
                            })
                        }

                        async function animateClose(x, y) {
                            return new Promise(async (resolve, reject) => {
                                var pos = 10;
                                var id = setInterval(frame, 10)

                                async function frame() {
                                    if (pos <= 0) {
                                        clearInterval(id);
                                        resolve("closeAnimate done");

                                    }
                                    else {
                                        pos = pos - 0.1;
                                        ctx.beginPath();
                                        ctx.strokeStyle = 'white';
                                        ctx.arc(x, y, 16 + pos, 0 * Math.PI, 2 * Math.PI);
                                        ctx.stroke();
                                        ctx.closePath();
                                    }
                                }
                            })
                        }

                        async function animateline(baseX, baseY, toX, toY) {
                            return new Promise(async (resolve, reject) => {
                                var direction = null;
                                if (toX < baseX) {
                                    //go left
                                    direction = -1;
                                    baseX = baseX - 15;
                                    baseY = baseY + 15;
                                    toX = toX + 15;
                                    toY = toY - 15;
                                }
                                else {
                                    direction = 1;
                                    baseX = baseX + 15;
                                    baseY = baseY + 15;
                                    toX = toX - 15;
                                    toY = toY - 15;
                                }
                                var timer = 0;
                                var id = setInterval(frame, 10);
                                var adjustedX = toX - baseX;
                                var adjustedY = toY - baseY;
                                adjustedY = Math.abs(adjustedY / 100);
                                adjustedX = Math.abs(adjustedX / 100);

                                async function frame() {
                                    if (timer == 100) {
                                        clearInterval(id);
                                        resolve("animateline done");
                                        //animatelineback()
                                    }
                                    else {
                                        timer++;
                                        console.log(baseX, baseY, toX, toY)
                                        baseX = baseX + (direction * adjustedX);;
                                        baseY = baseY + adjustedY;
                                        ctx.strokeStyle = 'Aquamarine';
                                        ctx.beginPath();
                                        ctx.moveTo(baseX + (2 * direction), baseY - 2);
                                        ctx.lineTo(baseX + (2 * direction * -1), baseY + 2);
                                        ctx.stroke();
                                        ctx.closePath();
                                    }
                                }
                            })


                        }

                        function log(type, msg) {
                            if (type == 0) {
                                document.getElementById("bst_logs").className = "alert bst_alert fade show hide alert-success"
                            }
                            else {
                                document.getElementById("bst_logs").className = "alert bst_alert fade show hide alert-danger"
                            }
                            document.getElementById("bst_logs").innerHTML = msg;
                            $('#bst_logs').show();
                        }


                        var BST = new BinarySearchTree();





                        //docs examples
                        var canvas2 = document.getElementById('animate_line_example');
                        var ctx2 = canvas2.getContext('2d');
                        ctx2.canvas.width = window.innerWidth * 0.30;
                        ctx2.canvas.height = window.innerHeight * 0.25;

                        function changespeed() {
                            ctx2.clearRect(0,0,ctx2.canvas.width,ctx2.canvas.height)
                            let speed = parseInt(document.getElementById("example_line").value);
                            animateline2(20, 20, ctx2.canvas.width - 20, 200, speed);
                        }

                        async function animateline2(baseX, baseY, toX, toY, speed) {
                                            return new Promise(async (resolve, reject) => {
                                                var direction = null;
                                                if (toX < baseX) {
                                                    //go left
                                                    direction = -1;
                                                    baseX = baseX - 15;
                                                    baseY = baseY + 15;
                                                    toX = toX + 15;
                                                    toY = toY - 15;
                                                }
                                                else {
                                                    direction = 1;
                                                    baseX = baseX + 15;
                                                    baseY = baseY + 15;
                                                    toX = toX - 15;
                                                    toY = toY - 15;
                                                }
                                                var timer = 0;
                                                var id = setInterval(frame, speed);
                                                var adjustedX = toX - baseX;
                                                var adjustedY = toY - baseY;
                                                adjustedY = Math.abs(adjustedY / 100);
                                                adjustedX = Math.abs(adjustedX / 100);

                                                async function frame() {
                                                    if (timer == 100) {
                                                        clearInterval(id);
                                                        resolve("animateline done");
                                                    }
                                                    else {

                                                        timer++;
                                                        console.log(baseX, baseY, toX, toY)
                                                        baseX = baseX + (direction * adjustedX);;
                                                        baseY = baseY + adjustedY;
                                                        ctx2.strokeStyle = 'Blue';
                                                        ctx2.beginPath();
                                                        ctx2.moveTo(baseX + (5 * direction), baseY - 5);
                                                        ctx2.lineTo(baseX + (5 * direction * -1), baseY + 5);
                                                        ctx2.stroke();
                                                        ctx2.closePath();
                                                    }
                                                }
                                            })
                        }

                        </code>
                    </pre>
                </div>
            </div>
        </div>




        <div class="card-footer text-muted">
            Updated January 9 2021
        </div>

        <script>


            var startY = 30;
            var x = 0;
            var y = 0;
            var canvas = document.getElementById('myCanvas');
            var ctx = canvas.getContext('2d');

            ctx.canvas.width = window.innerWidth;
            ctx.canvas.height = window.innerHeight * 0.50;

            ctx.fillStyle = 'black';
            ctx.strokeStyle = 'black';
            ctx.font = "20px Arial";


            class Node {
                constructor(data) {
                    this.data = data;
                    this.x = null;
                    this.y = null;
                    this.left = null;
                    this.right = null;
                    this.position = null; // left(0) or right(1) - needed to dynamically adjust position of leaf node. x-axis changes. adding new level require x-axis adjustment to fit and not overlap nodes
                    this.parent = null;
                    this.level = null;
                }
            }

            class BinarySearchTree {
                constructor() {
                    this.root = null;
                    this.bst_level = null;
                }


                async insert(data) {
                    if (data > 99){
                      log(1, "Max is 99");
                      return
                    }

                    if (data < -99){
                      log(1, "min is -99");
                      return
                    }
                    //clear canvas
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

                    //disable button until animation finish
                    document.getElementById("addNodeButton").disabled = true;
                    this.mapBST(this.root);
                    var newNode = new Node(data);

                    if (this.root === null) {
                        this.root = newNode;
                        this.bst_level = 0;
                        newNode.level = 0;
                        newNode.x = ctx.canvas.width / 2 - 30;
                        newNode.y = startY;
                        createCircle(newNode.x, newNode.y, newNode.data);
                        document.getElementById("addNodeButton").disabled = false;
                        await animateExpand(newNode.x, newNode.y);

                        log(0, "Root Node Created");

                    }
                    else {
                        this.insertNode(this.root, newNode);
                    }
                }


                async insertNode(node, newNode) {

                    //if data = data
                    if (node.data == newNode.data) {
                        //TODO
                        log(0, "Values equals each other")
                        document.getElementById("addNodeButton").disabled = false;
                    }
                    else if (node.data > newNode.data) { // go left ---------------
                        log(0, node.data + " is GREATER than " + newNode.data + ". Go Left")
                        if (node.left === null) {

                            newNode.parent = node;
                            newNode.position = 0;
                            newNode.y = node.y + 100;
                            newNode.level = node.level + 1;

                            if (newNode.level > 3) {  //limit bst level to 3
                                log(1, "Constraint: BST max level is set to 3")
                                document.getElementById("addNodeButton").disabled = false;
                            }
                            else {
                                if (newNode.level > this.bst_level) { //remap BST coordinates
                                    this.bst_level = newNode.level;
                                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                                    this.mapBST(this.root);
                                    //draw connect to parent until root
                                    this.connectToRoot(node);
                                }

                                node.left = newNode;
                                document.getElementById("addNodeButton").disabled = false;
                                //new
                                let temp = (Math.pow(2, (this.bst_level - node.level - 1)) * 80);
                                let baseX, baseY, toX, toY = null;
                                newNode.x = node.x - temp;

                                //animate

                                await animateExpand(node.x, node.y);
                                await animateClose(node.x, node.y);
                                await animateline(node.x, node.y, newNode.x, newNode.y);


                                log(0, "Node " + newNode.data + " added.")



                                connectCircle(baseX, baseY, toX, toY);
                                createCircle(newNode.x, newNode.y, newNode.data);
                                await animateExpand(newNode.x, newNode.y);
                                createCircle(newNode.x, newNode.y, newNode.data);
                            }


                        }
                        else {
                            await animateExpand(node.x, node.y);
                            await animateClose(node.x, node.y);
                            await animateline(node.x, node.y, node.left.x, node.left.y)
                            this.insertNode(node.left, newNode);
                        }
                    }

                    else {                                                      // go right --------------
                        log(0, node.data + " is LESS than " + newNode.data + ". Go Right")
                        if (node.right === null) {

                            newNode.parent = node;
                            newNode.position = 1;
                            newNode.y = node.y + 100;
                            newNode.level = node.level + 1;
                            if (newNode.level > 3) {  //limit bst level to 3
                                log(1, "Constraint: BST max level is set to 3")
                                document.getElementById("addNodeButton").disabled = false;
                            }
                            else {
                                if (newNode.level > this.bst_level) {
                                    this.bst_level = newNode.level;
                                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                                    this.mapBST(this.root);
                                    this.connectToRoot(node);
                                }

                                node.right = newNode;
                                document.getElementById("addNodeButton").disabled = false;


                                let temp = (Math.pow(2, (this.bst_level - node.level - 1)) * 80);
                                let baseX, baseY, toX, toY = null;
                                newNode.x = node.x + temp;

                                //animation
                                await animateExpand(node.x, node.y);
                                await animateClose(node.x, node.y);
                                await animateline(node.x, node.y, newNode.x, newNode.y);

                                log(0, "Node " + newNode.data + " added.")

                                connectCircle(baseX, baseY, toX, toY);
                                createCircle(newNode.x, newNode.y, newNode.data);
                                await animateExpand(newNode.x, newNode.y);
                                createCircle(newNode.x, newNode.y, newNode.data);
                            }

                        }
                        else {
                            await animateExpand(node.x, node.y);
                            await animateClose(node.x, node.y);
                            await animateline(node.x, node.y, node.right.x, node.right.y);
                            this.insertNode(node.right, newNode);
                        }
                    }

                }


                mapBST(node) {
                    if (node !== null) {

                        if (this.root !== node) {
                            let temp = (Math.pow(2, (this.bst_level - node.parent.level - 1)) * 80);
                            if (node.position == 0) {
                                node.x = node.parent.x - temp;
                            }
                            else {
                                node.x = node.parent.x + temp;
                            }
                            createCircle(node.x, node.y, node.data);
                            connectCircle(node.parent.x,node.parent.y,node.x, node.y);

                        }
                        else {
                            //draw root node
                            createCircle(node.x, node.y, node.data);
                        }
                        this.mapBST(node.left);
                        this.mapBST(node.right);
                    }

                }

                connectToRoot(node) {

                    if (this.root !== node) {

                        let baseX, baseY, toX, toY = null;
                        if (node.position == 0) {
                            baseX = node.parent.x - 15;
                            baseY = node.parent.y + 15;
                            toX = node.x + 15;
                            toY = node.y - 15;
                        }
                        else {
                            baseX = node.parent.x + 15;
                            baseY = node.parent.y + 15;
                            toX = node.x - 15;
                            toY = node.y - 15;
                        }
                        ctx.beginPath();
                        ctx.strokeStyle = 'Aquamarine';
                        ctx.moveTo(baseX, baseY);
                        ctx.lineTo(toX, toY);
                        ctx.lineWidth = 5;
                        ctx.stroke();
                        ctx.closePath();
                        ctx.lineWidth = 1;
                        connectCircle(node.parent.x, node.parent.y, node.x, node.y);
                        this.connectToRoot(node.parent);
                    }
                    else {
                        console.log("reached root");
                    }

                }

            }

            function addNode() {
                let nodeName = parseInt(document.getElementById("node").value);

                console.log("inserting" + nodeName);
                BST.insert(nodeName);
            }

            function createCircle(x, y, number) {
                ctx.beginPath();
                ctx.fillStyle = 'black';
                ctx.strokeStyle = 'black';
                ctx.fillText(number, x - 10, y + 8)


                ctx.arc(x, y, 15, 0 * Math.PI, 2 * Math.PI);
                ctx.stroke();
                ctx.closePath();
            }

            function connectCircle(baseX, baseY, toX, toY) {
                if (toX < baseX) {
                    //go left
                    baseX = baseX - 15;
                    baseY = baseY + 15;
                    toX = toX + 15;
                    toY = toY - 15;
                }
                else {
                    baseX = baseX + 15;
                    baseY = baseY + 15;
                    toX = toX - 15;
                    toY = toY - 15;
                }

                ctx.beginPath();
                ctx.strokeStyle = 'black';
                ctx.moveTo(baseX, baseY);
                ctx.lineTo(toX, toY);
                ctx.stroke();
                ctx.closePath();
            }

            //animation

            async function animateExpand(x, y) {
                return new Promise(async (resolve, reject) => {
                    var pos = 0;
                    var id = setInterval(frame, 10)

                    async function frame() {
                        if (pos >= 9) {
                            clearInterval(id);
                            resolve("expand done")
                        }
                        else {
                            pos = pos + 0.1;
                            ctx.beginPath();
                            ctx.strokeStyle = 'Aquamarine';
                            ctx.arc(x, y, 16 + pos, 0 * Math.PI, 2 * Math.PI);
                            ctx.stroke();
                            ctx.closePath();
                        }
                    }
                })
            }

            async function animateClose(x, y) {
                return new Promise(async (resolve, reject) => {
                    var pos = 10;
                    var id = setInterval(frame, 10)

                    async function frame() {
                        if (pos <= 0) {
                            clearInterval(id);
                            resolve("closeAnimate done");

                        }
                        else {
                            pos = pos - 0.1;
                            ctx.beginPath();
                            ctx.strokeStyle = 'white';
                            ctx.arc(x, y, 16 + pos, 0 * Math.PI, 2 * Math.PI);
                            ctx.stroke();
                            ctx.closePath();
                        }
                    }
                })
            }

            async function animateline(baseX, baseY, toX, toY) {
                return new Promise(async (resolve, reject) => {
                    var direction = null;
                    if (toX < baseX) {
                        //go left
                        direction = -1;
                        baseX = baseX - 15;
                        baseY = baseY + 15;
                        toX = toX + 15;
                        toY = toY - 15;
                    }
                    else {
                        direction = 1;
                        baseX = baseX + 15;
                        baseY = baseY + 15;
                        toX = toX - 15;
                        toY = toY - 15;
                    }
                    var timer = 0;
                    var id = setInterval(frame, 10);
                    var adjustedX = toX - baseX;
                    var adjustedY = toY - baseY;
                    adjustedY = Math.abs(adjustedY / 100);
                    adjustedX = Math.abs(adjustedX / 100);

                    async function frame() {
                        if (timer == 100) {
                            clearInterval(id);
                            resolve("animateline done");
                            //animatelineback()
                        }
                        else {
                            timer++;
                            console.log(baseX, baseY, toX, toY)
                            baseX = baseX + (direction * adjustedX);;
                            baseY = baseY + adjustedY;
                            ctx.strokeStyle = 'Aquamarine';
                            ctx.beginPath();
                            ctx.moveTo(baseX + (2 * direction), baseY - 2);
                            ctx.lineTo(baseX + (2 * direction * -1), baseY + 2);
                            ctx.stroke();
                            ctx.closePath();
                        }
                    }
                })


            }

            function log(type, msg) {
                if (type == 0) {
                    document.getElementById("bst_logs").className = "alert bst_alert fade show hide alert-success"
                }
                else {
                    document.getElementById("bst_logs").className = "alert bst_alert fade show hide alert-danger"
                }
                document.getElementById("bst_logs").innerHTML = msg;
                $('#bst_logs').show();
            }


            var BST = new BinarySearchTree();





            //docs examples
            var canvas2 = document.getElementById('animate_line_example');
            var ctx2 = canvas2.getContext('2d');
            ctx2.canvas.width = window.innerWidth * 0.30;
            ctx2.canvas.height = window.innerHeight * 0.25;

            function changespeed() {
                ctx2.clearRect(0,0,ctx2.canvas.width,ctx2.canvas.height)
                let speed = parseInt(document.getElementById("example_line").value);
                animateline2(20, 20, ctx2.canvas.width - 20, 200, speed);
            }

            async function animateline2(baseX, baseY, toX, toY, speed) {
                                return new Promise(async (resolve, reject) => {
                                    var direction = null;
                                    if (toX < baseX) {
                                        //go left
                                        direction = -1;
                                        baseX = baseX - 15;
                                        baseY = baseY + 15;
                                        toX = toX + 15;
                                        toY = toY - 15;
                                    }
                                    else {
                                        direction = 1;
                                        baseX = baseX + 15;
                                        baseY = baseY + 15;
                                        toX = toX - 15;
                                        toY = toY - 15;
                                    }
                                    var timer = 0;
                                    var id = setInterval(frame, speed);
                                    var adjustedX = toX - baseX;
                                    var adjustedY = toY - baseY;
                                    adjustedY = Math.abs(adjustedY / 100);
                                    adjustedX = Math.abs(adjustedX / 100);

                                    async function frame() {
                                        if (timer == 100) {
                                            clearInterval(id);
                                            resolve("animateline done");
                                        }
                                        else {

                                            timer++;
                                            console.log(baseX, baseY, toX, toY)
                                            baseX = baseX + (direction * adjustedX);;
                                            baseY = baseY + adjustedY;
                                            ctx2.strokeStyle = 'Blue';
                                            ctx2.beginPath();
                                            ctx2.moveTo(baseX + (5 * direction), baseY - 5);
                                            ctx2.lineTo(baseX + (5 * direction * -1), baseY + 5);
                                            ctx2.stroke();
                                            ctx2.closePath();
                                        }
                                    }
                                })
            }

        </script>

    </div>
</html>
